<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Migrating M4 macros - rules_cc_autoconf</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rules_cc_autoconf</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/periareon/rules_cc_autoconf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="migrating-from-m4-macros"><a class="header" href="#migrating-from-m4-macros">Migrating from M4 macros</a></h1>
<p>GNU Autoconf uses M4 macros in <code>configure.ac</code> files to generate configuration
checks. This module provides equivalent Starlark functions that produce the same
results but are integrated with Bazel's build system.</p>
<h2 id="key-differences"><a class="header" href="#key-differences">Key Differences</a></h2>
<ol>
<li><strong>Syntax</strong>: M4 uses square brackets <code>[]</code> for arguments; Starlark uses parentheses <code>()</code> and quotes <code>""</code></li>
<li><strong>Multiple items</strong>: M4 macros like <code>AC_CHECK_HEADERS([h1 h2 h3])</code> become multiple separate calls</li>
<li><strong>Action blocks</strong>: M4 uses action blocks <code>[action-if-found]</code> and <code>[action-if-not-found]</code>; Bazel uses <code>if_true</code>/<code>if_found</code> and <code>if_false</code>/<code>if_not_found</code> parameters (see Pattern 11c)</li>
<li><strong>Language selection</strong>: M4 uses <code>AC_LANG_PUSH([C++])</code>; Bazel uses <code>language = "cpp"</code> parameter</li>
<li><strong>Custom code</strong>: M4 uses <code>AC_LANG_PROGRAM([includes], [body])</code>; Bazel uses <code>code</code> or <code>file</code> parameters</li>
<li><strong>Dependencies</strong>: M4 uses nested macro calls; Bazel uses explicit <code>requires</code> parameter or <code>if_true</code>/<code>if_false</code> for conditional execution</li>
</ol>
<h2 id="migration-patterns"><a class="header" href="#migration-patterns">Migration Patterns</a></h2>
<h3 id="pattern-1-simple-headerfunctiontype-checks"><a class="header" href="#pattern-1-simple-headerfunctiontype-checks">Pattern 1: Simple Header/Function/Type Checks</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_HEADER([stdio.h])
AC_CHECK_FUNC([malloc])
AC_CHECK_TYPE([size_t])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_HEADER("stdio.h")
macros.AC_CHECK_FUNC("malloc")
macros.AC_CHECK_TYPE("size_t")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Remove square brackets, add quotes</li>
<li>Convert to function call: <code>macros.MACRO_NAME("argument")</code></li>
<li>Define names are auto-generated (e.g., <code>HAVE_STDIO_H</code>, <code>HAVE_MALLOC</code>, <code>HAVE_SIZE_T</code>)</li>
</ul>
<h3 id="pattern-2-multiple-items-in-one-call"><a class="header" href="#pattern-2-multiple-items-in-one-call">Pattern 2: Multiple Items in One Call</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_HEADERS([stdio.h stdlib.h string.h])
AC_CHECK_FUNCS([malloc free printf])
AC_CHECK_TYPES([int8_t int64_t])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_HEADER("stdio.h")
macros.AC_CHECK_HEADER("stdlib.h")
macros.AC_CHECK_HEADER("string.h")
macros.AC_CHECK_FUNC("malloc")
macros.AC_CHECK_FUNC("free")
macros.AC_CHECK_FUNC("printf")
macros.AC_CHECK_TYPE("int8_t")
macros.AC_CHECK_TYPE("int64_t")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Split space-separated lists into individual macro calls</li>
<li>Each item becomes a separate function call</li>
</ul>
<h3 id="pattern-3-custom-define-names"><a class="header" href="#pattern-3-custom-define-names">Pattern 3: Custom Define Names</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_HEADER([sys/stat.h], [AC_DEFINE([HAVE_SYS_STAT_H], [1])])
AC_CHECK_FUNC([printf], [AC_DEFINE([HAVE_PRINTF], [1])])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_HEADER("sys/stat.h", define = "HAVE_SYS_STAT_H")
macros.AC_CHECK_FUNC("printf", define = "HAVE_PRINTF")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Extract define name from <code>AC_DEFINE</code> in action block</li>
<li>Use <code>define</code> parameter to override auto-generated name</li>
<li>If no custom define, omit the parameter (auto-generation handles it)</li>
</ul>
<h3 id="pattern-4-headers-for-typesymbol-checks"><a class="header" href="#pattern-4-headers-for-typesymbol-checks">Pattern 4: Headers for Type/Symbol Checks</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_TYPE([int64_t], [], [], [[#include &lt;stdint.h&gt;]])
AC_CHECK_SYMBOL([NULL], [], [], [[#include &lt;stddef.h&gt;]])
AC_CHECK_TYPES([int8_t, int64_t], [], [], [[#include &lt;stdint.h&gt;]])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_TYPE("int64_t", code = "#include &lt;stdint.h&gt;")
macros.AC_CHECK_SYMBOL("NULL", code = "#include &lt;stddef.h&gt;")
macros.AC_CHECK_TYPE("int8_t", code = "#include &lt;stdint.h&gt;")
macros.AC_CHECK_TYPE("int64_t", code = "#include &lt;stdint.h&gt;")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Extract include directives from the 4th argument (includes parameter)</li>
<li>Use <code>code</code> parameter with the include statement</li>
<li>For <code>AC_CHECK_TYPES</code> with multiple types, split and repeat the code for each</li>
</ul>
<p><strong>Note on Implicit Defines:</strong></p>
<p>In GNU autoconf, <code>AC_CHECK_TYPES</code> may implicitly define <code>HAVE_*</code> values for headers
it checks. For example, when checking types that require <code>&lt;stdint.h&gt;</code>, autoconf may
also check for <code>&lt;inttypes.h&gt;</code> and define <code>HAVE_INTTYPES_H</code>. Similarly, <code>STDC_HEADERS</code>
is typically defined by <code>AC_HEADER_STDC</code> which checks for standard C89 headers.</p>
<p>In rules_cc_autoconf, these implicit checks are not performed automatically. If your
template file (e.g., <code>config.h.in</code>) contains <code>#undef</code> statements for these defines,
you must explicitly add the corresponding checks to your BUILD file:</p>
<pre><code class="language-python"># If checking types that require stdint.h, also check for inttypes.h
macros.AC_CHECK_HEADER("inttypes.h")

# If STDC_HEADERS is in your template, define it explicitly
macros.AC_DEFINE("STDC_HEADERS", "1")
</code></pre>
<h3 id="pattern-5-custom-compilation-tests"><a class="header" href="#pattern-5-custom-compilation-tests">Pattern 5: Custom Compilation Tests</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
#include &lt;stdatomic.h&gt;
]], [[
atomic_int x = 0;
(void)x;
return 0;
]])], [AC_DEFINE([HAVE_STDATOMIC], [1])], [])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_TRY_COMPILE(
    code = """\
#include &lt;stdatomic.h&gt;
int main(void) { atomic_int x = 0; (void)x; return 0; }
""",
    define = "HAVE_STDATOMIC",
)
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li><code>AC_COMPILE_IFELSE</code> → <code>macros.AC_TRY_COMPILE</code></li>
<li>Combine <code>AC_LANG_PROGRAM</code> includes and body into single <code>code</code> string</li>
<li>Extract define from action block</li>
<li>Add <code>int main(void) { ... }</code> wrapper if not present</li>
<li>Use <code>\n</code> for line breaks in code string</li>
</ul>
<h3 id="pattern-6-language-selection"><a class="header" href="#pattern-6-language-selection">Pattern 6: Language Selection</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_LANG_PUSH([C++])
AC_CHECK_HEADER([iostream])
AC_LANG_POP([C++])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_HEADER("iostream", language = "cpp")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li><code>AC_LANG_PUSH([C++])</code> / <code>AC_LANG_POP([C++])</code> → add <code>language = "cpp"</code> to all macros in between</li>
<li><code>AC_LANG_PUSH([C])</code> is the default, so usually no parameter needed</li>
<li>Apply <code>language = "cpp"</code> to all macros between <code>AC_LANG_PUSH([C++])</code> and <code>AC_LANG_POP([C++])</code></li>
</ul>
<h3 id="pattern-7-library-checks"><a class="header" href="#pattern-7-library-checks">Pattern 7: Library Checks</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_LIB([m], [cos])
AC_CHECK_LIB([pthread], [pthread_create])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_LIB("m", "cos")
macros.AC_CHECK_LIB("pthread", "pthread_create")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>First argument is library name (without <code>-l</code> prefix)</li>
<li>Second argument is function name to check</li>
<li>Define auto-generated as <code>HAVE_LIB&lt;LIBRARY&gt;</code> (e.g., <code>HAVE_LIBM</code>)</li>
</ul>
<h3 id="pattern-8-compiler-flag-checks"><a class="header" href="#pattern-8-compiler-flag-checks">Pattern 8: Compiler Flag Checks</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_MSG_CHECKING([whether $CC accepts -Wall])
save_CFLAGS="$CFLAGS"
CFLAGS="$CFLAGS -Wall"
AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])],
  [AC_MSG_RESULT([yes])
   AC_DEFINE([HAVE_FLAG_WALL], [1])],
  [AC_MSG_RESULT([no])])
CFLAGS="$save_CFLAGS"
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_C_COMPILER_FLAG("-Wall", define = "HAVE_FLAG_WALL")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Pattern of <code>AC_MSG_CHECKING</code> + flag manipulation + <code>AC_COMPILE_IFELSE</code> → <code>AC_CHECK_C_COMPILER_FLAG</code></li>
<li>Extract flag from <code>CFLAGS</code> or <code>CXXFLAGS</code> assignment</li>
<li>Extract define from action block</li>
<li>Use <code>AC_CHECK_C_COMPILER_FLAG</code> for C, <code>AC_CHECK_CXX_COMPILER_FLAG</code> for C++</li>
</ul>
<h3 id="pattern-9-size-and-alignment-checks"><a class="header" href="#pattern-9-size-and-alignment-checks">Pattern 9: Size and Alignment Checks</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_SIZEOF([int])
AC_CHECK_SIZEOF([size_t], [], [[#include &lt;stddef.h&gt;]])
AC_CHECK_ALIGNOF([double])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_SIZEOF("int")
macros.AC_CHECK_SIZEOF("size_t", headers = ["stddef.h"])
macros.AC_CHECK_ALIGNOF("double")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Direct translation with type name</li>
<li>If includes provided, use <code>headers</code> parameter (list of header names without <code>&lt;&gt;</code> or quotes)</li>
<li>Define auto-generated as <code>SIZEOF_&lt;TYPE&gt;</code> or <code>ALIGNOF_&lt;TYPE&gt;</code></li>
</ul>
<h3 id="pattern-10-unconditional-defines-ac_define"><a class="header" href="#pattern-10-unconditional-defines-ac_define">Pattern 10: Unconditional Defines (AC_DEFINE)</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_DEFINE([CUSTOM_VALUE], [42])
AC_DEFINE([ENABLE_FEATURE], [1])
AC_DEFINE([PROJECT_NAME], ["MyProject"])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_DEFINE("CUSTOM_VALUE", "42")
macros.AC_DEFINE("ENABLE_FEATURE", "1")
macros.AC_DEFINE("PROJECT_NAME", '"MyProject"')
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Direct translation</li>
<li>Second argument becomes <code>value</code> parameter</li>
<li>Preserve quotes in string values (use <code>'"string"'</code> for string literals)</li>
</ul>
<h3 id="pattern-10b-m4-shell-variables-m4_define"><a class="header" href="#pattern-10b-m4-shell-variables-m4_define">Pattern 10b: M4 Shell Variables (M4_DEFINE)</a></h3>
<p>Many M4 macros use shell variables like <code>REPLACE_*</code> or <code>HAVE_*</code> that are set via
assignment (not <code>AC_DEFINE</code>). These are tracked separately using <code>M4_DEFINE</code>.</p>
<p><strong>M4:</strong></p>
<pre><code class="language-m4"># These are shell variable assignments, NOT AC_DEFINE calls
REPLACE_FSTAT=1
HAVE_WORKING_MKTIME=0
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python"># Use M4_DEFINE for shell variables
macros.M4_DEFINE("REPLACE_FSTAT", "1")
macros.M4_DEFINE("HAVE_WORKING_MKTIME", "0")
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Use <code>macros.M4_DEFINE</code> for M4 shell variable assignments (e.g., <code>REPLACE_*=1</code>)</li>
<li>Use <code>macros.AC_DEFINE</code> only for actual <code>AC_DEFINE()</code> calls in the M4 source</li>
<li>Both produce the same result, but <code>M4_DEFINE</code> helps track the semantic difference</li>
</ul>
<h3 id="pattern-11-conditional-dependencies"><a class="header" href="#pattern-11-conditional-dependencies">Pattern 11: Conditional Dependencies</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_HEADER([stdio.h])
AC_CHECK_FUNC([fopen], [], [], [[#include &lt;stdio.h&gt;]])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_HEADER("stdio.h")
macros.AC_CHECK_FUNC("fopen", requires = ["HAVE_STDIO_H"])
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>If a check includes a header that was previously checked, add <code>requires</code> parameter</li>
<li>Use the auto-generated define name from the previous check</li>
<li>Extract include dependencies and map to corresponding <code>HAVE_*</code> defines</li>
</ul>
<h3 id="pattern-11b-value-based-requirements"><a class="header" href="#pattern-11b-value-based-requirements">Pattern 11b: Value-Based Requirements</a></h3>
<p>Sometimes a check should only run if a previous check resulted in a specific value.
Use <code>"DEFINE=value"</code> syntax in the <code>requires</code> list.</p>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">if test $REPLACE_FSTAT = 1; then
  # Only run this check if fstat needs replacement
  AC_CHECK_FUNC([fstat64])
fi
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_FUNC(
    "fstat64",
    requires = ["REPLACE_FSTAT=1"],  # Only if REPLACE_FSTAT equals "1"
)
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li><code>requires = ["FOO"]</code> - check succeeds if FOO succeeded (any value)</li>
<li><code>requires = ["FOO=1"]</code> - check succeeds if FOO succeeded AND has value "1"</li>
<li>Useful for conditional checks based on platform detection results</li>
</ul>
<h3 id="pattern-11c-conditional-action-blocks-if_trueif_found"><a class="header" href="#pattern-11c-conditional-action-blocks-if_trueif_found">Pattern 11c: Conditional Action Blocks (<code>if_true</code>/<code>if_found</code>)</a></h3>
<p>Many M4 macros support action blocks that run conditionally based on whether a check succeeds or fails. The <code>[action-if-found]</code> or <code>[action-if-true]</code> block runs when the check succeeds, and <code>[action-if-not-found]</code> or <code>[action-if-false]</code> runs when it fails.</p>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_HEADER([stdio.h],
    [
        # Action if found: run additional checks
        AC_CHECK_FUNC([printf])
        AC_CHECK_FUNC([fprintf])
    ],
    [
        # Action if not found: define fallback
        AC_DEFINE([NO_STDIO], [1])
    ]
)

AC_CHECK_FUNCS([ffs],
    [
        # If ffs() exists, check if it's declared in strings.h
        AC_CHECK_DECL([ffs], 
            [AC_DEFINE([STRINGS_H_DECLARES_FFS], [1])],
            [],
            [[#include &lt;strings.h&gt;]]
        )
    ]
)
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_HEADER(
    "stdio.h",
    if_true = [
        # These checks run only if stdio.h exists
        macros.AC_CHECK_FUNC("printf"),
        macros.AC_CHECK_FUNC("fprintf"),
    ],
    if_false = [
        # This runs only if stdio.h doesn't exist
        macros.AC_DEFINE("NO_STDIO", "1"),
    ],
)

macros.AC_CHECK_FUNC(
    "ffs",
    if_true = [
        # This runs only if ffs() exists
        macros.AC_CHECK_DECL(
            "ffs",
            define = "STRINGS_H_DECLARES_FFS",
            headers = ["strings.h"],
        ),
    ],
)
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li><code>if_true</code> and <code>if_found</code> are aliases - use either one (they're equivalent)</li>
<li><code>if_false</code> and <code>if_not_found</code> are aliases - use either one (they're equivalent)</li>
<li>You cannot provide both <code>if_true</code> and <code>if_found</code> (same for <code>if_false</code>/<code>if_not_found</code>)</li>
<li>Action blocks become lists of macro calls passed to <code>if_true</code>/<code>if_false</code> parameters</li>
<li>Nested checks in <code>if_true</code> automatically receive a <code>requires</code> dependency on the parent check's define</li>
<li>Nested checks in <code>if_false</code> automatically receive a <code>requires</code> dependency on <code>!PARENT_DEFINE</code> (negated)</li>
<li>The flattening process ensures nested checks are executed as separate Bazel actions with proper dependencies</li>
<li>Use this pattern instead of manually adding <code>requires</code> when you want conditional execution based on a check result</li>
</ul>
<p><strong>Relationship to <code>requires</code>:</strong></p>
<p>The <code>if_true</code>/<code>if_false</code> parameters are syntactic sugar that automatically generate <code>requires</code> dependencies. The following are equivalent:</p>
<pre><code class="language-python"># Using if_true (preferred for conditional checks)
macros.AC_CHECK_HEADER(
    "stdio.h",
    if_true = [
        macros.AC_CHECK_FUNC("printf"),
    ],
)

# Equivalent manual requires
macros.AC_CHECK_HEADER("stdio.h")
macros.AC_CHECK_FUNC(
    "printf",
    requires = ["HAVE_STDIO_H"],
)
</code></pre>
<p>However, <code>if_true</code>/<code>if_false</code> is cleaner when you have conditional action blocks because it clearly shows the intent and keeps related checks together.</p>
<p><strong>Advanced: Nested Conditionals:</strong></p>
<p>You can nest conditional checks to create complex dependency chains:</p>
<pre><code class="language-python">macros.AC_CHECK_HEADER(
    "stdio.h",
    if_true = [
        macros.AC_CHECK_FUNC(
            "printf",
            if_true = [
                # This runs only if both stdio.h exists AND printf exists
                macros.AC_DEFINE("HAVE_PRINTF_IN_STDIO", "1"),
            ],
        ),
    ],
)
</code></pre>
<h3 id="pattern-12-member-checks"><a class="header" href="#pattern-12-member-checks">Pattern 12: Member Checks</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_MEMBER([struct stat.st_rdev], [AC_DEFINE([HAVE_STRUCT_STAT_ST_RDEV], [1])], [], [[#include &lt;sys/stat.h&gt;]])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_MEMBER("struct stat", "st_rdev", headers = ["sys/stat.h"])
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Split <code>struct/union.member</code> into two arguments: aggregate and member</li>
<li>Extract includes to <code>headers</code> parameter</li>
<li>Define auto-generated as <code>HAVE_&lt;AGGREGATE&gt;_&lt;MEMBER&gt;</code></li>
</ul>
<h3 id="pattern-13-declaration-checks"><a class="header" href="#pattern-13-declaration-checks">Pattern 13: Declaration Checks</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_CHECK_DECL([NULL], [AC_DEFINE([HAVE_DECL_NULL], [1])], [], [[#include &lt;stddef.h&gt;]])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_DECL("NULL", headers = ["stddef.h"])
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Similar to <code>AC_CHECK_SYMBOL</code> but checks for declarations (not just definitions)</li>
<li>Use <code>headers</code> parameter for includes</li>
<li>Define auto-generated as <code>HAVE_DECL_&lt;SYMBOL&gt;</code></li>
</ul>
<h3 id="pattern-13b-conditional-declaration-checks-with-function-pre-checks"><a class="header" href="#pattern-13b-conditional-declaration-checks-with-function-pre-checks">Pattern 13b: Conditional Declaration Checks with Function Pre-checks</a></h3>
<p>Sometimes you need to check if a function exists first, then check if it's declared in a specific header. The original M4 code uses shell conditionals to chain these checks.</p>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">if test "$ac_cv_func_ether_hostton" = yes; then
    #
    # OK, we have ether_hostton().  Is it declared in &lt;net/ethernet.h&gt;?
    #
    # This test fails if we don't have &lt;net/ethernet.h&gt; or if we do
    # but it doesn't declare ether_hostton().
    #
    AC_CHECK_DECL(ether_hostton,
        [
            AC_DEFINE(NET_ETHERNET_H_DECLARES_ETHER_HOSTTON,,
                [Define to 1 if net/ethernet.h declares `ether_hostton'])
        ],,
        [
#include &lt;net/ethernet.h&gt;
        ])
fi
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">macros.AC_CHECK_FUNC("ether_hostton"),
macros.AC_CHECK_DECL(
    "ether_hostton",
    define = "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST",
    headers = ["net/ethernet.h"],
    requires = ["HAVE_ETHER_HOSTTON=1"],
),
macros.AC_DEFINE(
    "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON",
    requires = ["NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=1"],
),
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>First check if the function exists with <code>AC_CHECK_FUNC</code></li>
<li>Then check if it's declared in the header with <code>AC_CHECK_DECL</code>, using a temporary define name (e.g., <code>*_TEST</code>)</li>
<li>Use <code>requires = ["HAVE_ETHER_HOSTTON=1"]</code> on the <code>AC_CHECK_DECL</code> to ensure it only runs if the function check succeeded</li>
<li>Finally, use <code>AC_DEFINE</code> with <code>requires = ["*_TEST=1"]</code> to conditionally define the final macro only if the declaration check passed</li>
<li>The <code>requires</code> chains ensure defines are not created unless they're supposed to, matching the original M4 shell conditional behavior</li>
</ul>
<h3 id="pattern-13c-reusing-common-checks-from-rules_cc_autoconfgnulibm4"><a class="header" href="#pattern-13c-reusing-common-checks-from-rules_cc_autoconfgnulibm4">Pattern 13c: Reusing Common Checks from <code>@rules_cc_autoconf//gnulib/m4</code></a></h3>
<p>Many common autoconf checks are already implemented as reusable targets in <code>@rules_cc_autoconf//gnulib/m4</code>.
Instead of manually writing checks for standard functions, headers, or types, you should
use these pre-built targets whenever possible. This ensures consistency, reduces duplication,
and avoids "duplicate check" errors.</p>
<p><strong>Before (Manual Checks):</strong></p>
<pre><code class="language-python">autoconf(
    name = "autoconf",
    checks = [
        macros.AC_CHECK_FUNC("lstat"),
        macros.AC_CHECK_HEADER("sys/stat.h"),
        macros.AC_CHECK_FUNC("access"),
        macros.AC_CHECK_HEADER("unistd.h"),
    ],
    deps = [":package"],
)
</code></pre>
<p><strong>After (Using <code>//gnulib/m4</code> Targets):</strong></p>
<pre><code class="language-python">autoconf(
    name = "autoconf",
    checks = [
        # Only add checks that aren't available in gnulib
        macros.AC_DEFINE("CUSTOM_FEATURE", "1"),
    ],
    deps = [
        ":package",
        "@rules_cc_autoconf//gnulib/m4/lstat",      # Provides AC_CHECK_FUNC("lstat") and related checks
        "//gnulib/m4/sys_stat_h",  # Provides AC_CHECK_HEADER("sys/stat.h")
        "@rules_cc_autoconf//gnulib/m4/access",      # Provides AC_CHECK_FUNC("access") and platform-specific logic
        "@rules_cc_autoconf//gnulib/m4/unistd_h",    # Provides AC_CHECK_HEADER("unistd.h")
    ],
)
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li><strong>Check for existing targets first</strong>: Before writing a check, look in <code>@rules_cc_autoconf//gnulib/m4/</code> for a target
that provides the same functionality (e.g., <code>@rules_cc_autoconf//gnulib/m4/lstat</code> for <code>lstat</code> checks)</li>
<li><strong>Use as dependencies</strong>: Add <code>@rules_cc_autoconf//gnulib/m4/&lt;name&gt;</code> targets to the <code>deps</code> list of your <code>autoconf</code> rule</li>
<li><strong>Don't duplicate checks</strong>: If a <code>//gnulib/m4</code> target already performs a check, don't add the same
check manually - this will cause a "duplicate check" error</li>
<li><strong>Benefits</strong>:
<ul>
<li>Common checks are tested and maintained centrally</li>
<li>Platform-specific logic is already handled (e.g., Windows/macOS special cases)</li>
<li>Reduces code duplication across projects</li>
<li>Ensures consistent define names and behavior</li>
</ul>
</li>
</ul>
<p><strong>Finding Available Targets:</strong></p>
<ul>
<li>Browse the <code>@rules_cc_autoconf//gnulib/m4/</code> directory to see available targets</li>
<li>Common patterns:
<ul>
<li>Function checks: <code>@rules_cc_autoconf//gnulib/m4/&lt;function_name&gt;</code> (e.g., <code>@rules_cc_autoconf//gnulib/m4/lstat</code>, <code>@rules_cc_autoconf//gnulib/m4/access</code>)</li>
<li>Header checks: <code>@rules_cc_autoconf//gnulib/m4/&lt;header_name&gt;</code> (e.g., <code>@rules_cc_autoconf//gnulib/m4/sys_stat_h</code>, <code>@rules_cc_autoconf//gnulib/m4/unistd_h</code>)</li>
<li>Type checks: <code>@rules_cc_autoconf//gnulib/m4/&lt;type_name&gt;</code> (e.g., <code>@rules_cc_autoconf//gnulib/m4/off_t</code>, <code>@rules_cc_autoconf//gnulib/m4/mode_t</code>)</li>
</ul>
</li>
</ul>
<p><strong>Example with Platform-Specific Logic:</strong></p>
<p>The <code>//gnulib/m4</code> targets often include platform-specific conditionals that you'd otherwise
need to implement manually:</p>
<pre><code class="language-python"># Instead of manually implementing:
autoconf(
    name = "autoconf",
    checks = select({
        "@platforms//os:windows": [
            macros.M4_DEFINE("REPLACE_ACCESS", "1"),
        ],
        "//conditions:default": [
            macros.AC_CHECK_FUNC("access"),
        ],
    }),
    deps = [":package"],
)

# Use the pre-built target:
autoconf(
    name = "autoconf",
    checks = [
        # Your custom checks here
    ],
    deps = [
        ":package",
        "//gnulib/m4/access",  # Handles Windows and other platform logic automatically
    ],
)
</code></pre>
<h3 id="pattern-14-platform-specific-conditionals"><a class="header" href="#pattern-14-platform-specific-conditionals">Pattern 14: Platform-Specific Conditionals</a></h3>
<p>Many M4 files use <code>case "$host_os"</code> to conditionally set variables based on the
target platform. In Bazel, these should be translated to <code>select()</code> statements.</p>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_REQUIRE([AC_CANONICAL_HOST])
case "$host_os" in
  mingw* | windows*)
    REPLACE_ACCESS=1
    ;;
  *)
    # Other platform checks...
    ;;
esac
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">autoconf(
    name = "access",
    checks = select({
        "@platforms//os:windows": [
            # On Windows, unconditionally set REPLACE_ACCESS=1
            # Use M4_DEFINE for M4 shell variables (not AC_DEFINE values)
            macros.M4_DEFINE("REPLACE_ACCESS", "1"),
        ],
        "//conditions:default": [
            # Non-Windows checks
            macros.AC_CHECK_FUNC("access"),
        ],
    }),
    visibility = ["//visibility:public"],
    deps = [...],
)
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Use <code>macros.M4_DEFINE</code> for M4 shell variables (e.g., <code>REPLACE_*</code>, <code>HAVE_*</code> set via assignment)</li>
<li>Use <code>macros.AC_DEFINE</code> only for actual <code>AC_DEFINE()</code> calls in the M4 source</li>
<li><code>case "$host_os" in mingw* | windows*)</code> → <code>select({"@platforms//os:windows": [...]})</code></li>
<li><code>case "$host_os" in darwin*)</code> → <code>select({"@platforms//os:macos": [...]})</code></li>
<li><code>case "$host_os" in linux*)</code> → <code>select({"@platforms//os:linux": [...]})</code></li>
<li>Default case (<code>*</code>) → <code>"//conditions:default": [...]</code></li>
<li>Multiple platform conditions can be combined in a single <code>select()</code></li>
<li>Checks inside the <code>select()</code> must be lists that can be concatenated with <code>+</code></li>
</ul>
<p><strong>Common Platform Constraint Labels:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>M4 Pattern</th><th>Bazel Constraint</th></tr></thead><tbody>
<tr><td><code>mingw*</code>, <code>windows*</code></td><td><code>@platforms//os:windows</code></td></tr>
<tr><td><code>darwin*</code></td><td><code>@platforms//os:macos</code></td></tr>
<tr><td><code>linux*</code>, <code>linux-*</code></td><td><code>@platforms//os:linux</code></td></tr>
<tr><td><code>freebsd*</code></td><td><code>@platforms//os:freebsd</code></td></tr>
<tr><td><code>openbsd*</code></td><td><code>@platforms//os:openbsd</code></td></tr>
<tr><td><code>netbsd*</code></td><td><code>@platforms//os:netbsd</code></td></tr>
<tr><td><code>solaris*</code></td><td>(use custom constraint or <code>//conditions:default</code>)</td></tr>
<tr><td><code>cygwin*</code></td><td>(use custom constraint or <code>//conditions:default</code>)</td></tr>
</tbody></table>
</div>
<p><strong>Example with Multiple Platforms:</strong></p>
<pre><code class="language-python">autoconf(
    name = "fstat",
    checks = select({
        "@platforms//os:windows": [
            # Windows: stat returns timezone-affected timestamps
            macros.M4_DEFINE("REPLACE_FSTAT", "1"),
        ],
        "@platforms//os:macos": [
            # macOS: stat can return negative tv_nsec
            macros.M4_DEFINE("REPLACE_FSTAT", "1"),
        ],
        "//conditions:default": [
            # Other platforms: no replacement needed
        ],
    }),
    visibility = ["//visibility:public"],
)
</code></pre>
<p><strong>Combining Platform Checks with Common Checks:</strong></p>
<p>When you need both platform-specific and common checks, concatenate them with <code>+</code>:</p>
<pre><code class="language-python">autoconf(
    name = "open",
    checks = [
        # Common checks for all platforms
        macros.AC_CHECK_FUNC("open"),
    ] + select({
        "@platforms//os:windows": [
            # Windows-specific: unconditionally replace open()
            macros.M4_DEFINE("REPLACE_OPEN", "1"),
        ],
        "//conditions:default": [],
    }),
    visibility = ["//visibility:public"],
    deps = [...],
)
</code></pre>
<h2 id="special-cases"><a class="header" href="#special-cases">Special Cases</a></h2>
<h3 id="ac_init-and-ac_config_headers"><a class="header" href="#ac_init-and-ac_config_headers">AC_INIT and AC_CONFIG_HEADERS</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_INIT([package_name], [1.0.0])
AC_CONFIG_HEADERS([config.h])
</code></pre>
<p><strong>Bazel:</strong></p>
<pre><code class="language-python">package_info(
    name = "package",
    package_name = "package_name",
    package_version = "1.0.0",
)

autoconf_hdr(
    name = "config",
    out = "config.h",
    template = "config.h.in",
    deps = [":autoconf"],
)
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li><code>AC_INIT</code> → <code>package_info</code> rule (separate from macros)</li>
<li><code>AC_CONFIG_HEADERS</code> → <code>autoconf_hdr</code> rule (separate from macros)</li>
</ul>
<h3 id="ac_output"><a class="header" href="#ac_output">AC_OUTPUT</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_OUTPUT
</code></pre>
<p><strong>Bazel:</strong></p>
<ul>
<li>No equivalent - handled by Bazel build system automatically</li>
</ul>
<h3 id="ac_msg_checking--ac_msg_result"><a class="header" href="#ac_msg_checking--ac_msg_result">AC_MSG_CHECKING / AC_MSG_RESULT</a></h3>
<p><strong>M4:</strong></p>
<pre><code class="language-m4">AC_MSG_CHECKING([for something])
AC_MSG_RESULT([yes])
</code></pre>
<p><strong>Bazel:</strong></p>
<ul>
<li>No equivalent - informational only, not needed in Bazel</li>
</ul>
<h2 id="complete-example-migration"><a class="header" href="#complete-example-migration">Complete Example Migration</a></h2>
<p><strong>M4 (configure.ac):</strong></p>
<pre><code class="language-m4">AC_INIT([myproject], [1.0.0])
AC_CONFIG_HEADERS([config.h])

AC_PROG_CC
AC_CHECK_HEADERS([stdio.h stdlib.h])
AC_CHECK_FUNCS([malloc printf])
AC_CHECK_TYPE([int64_t], [], [], [[#include &lt;stdint.h&gt;]])
AC_CHECK_LIB([m], [cos])
AC_DEFINE([MY_FEATURE], [1])
AC_OUTPUT
</code></pre>
<p><strong>Bazel (BUILD.bazel) - Using <code>//gnulib/m4</code> targets where possible:</strong></p>
<pre><code class="language-python">load("@rules_cc_autoconf//autoconf:autoconf.bzl", "autoconf")
load("@rules_cc_autoconf//autoconf:autoconf_hdr.bzl", "autoconf_hdr")
load("@rules_cc_autoconf//autoconf:macros.bzl", "macros")
load("@rules_cc_autoconf//autoconf:package_info.bzl", "package_info")

package_info(
    name = "package",
    package_name = "myproject",
    package_version = "1.0.0",
)

autoconf(
    name = "autoconf",
    checks = [
        macros.AC_PROG_CC(),
        # Note: stdio.h and stdlib.h checks may be provided by gnulib targets
        # if you depend on them, but we'll keep them explicit here for clarity
        macros.AC_CHECK_HEADER("stdio.h"),
        macros.AC_CHECK_HEADER("stdlib.h"),
        # Use gnulib targets for common function checks when available
        # (malloc and printf are standard, so we keep them explicit)
        macros.AC_CHECK_FUNC("malloc"),
        macros.AC_CHECK_FUNC("printf"),
        macros.AC_CHECK_TYPE("int64_t", code = "#include &lt;stdint.h&gt;"),
        macros.AC_CHECK_LIB("m", "cos"),
        macros.AC_DEFINE("MY_FEATURE", "1"),
    ],
    deps = [
        ":package",
        # Add gnulib targets for any common checks you need
        # Example: if you also needed lstat, you'd add:
        # "//gnulib/m4/lstat",
    ],
)

autoconf_hdr(
    name = "config",
    out = "config.h",
    template = "config.h.in",
    deps = [":autoconf"],
)
</code></pre>
<p><strong>Note:</strong> In practice, if your project uses functions like <code>lstat</code>, <code>access</code>, or other common POSIX
functions, check <code>//gnulib/m4/</code> first and add those targets to <code>deps</code> instead of writing the checks
manually. This example shows the basic migration pattern, but always prefer <code>//gnulib/m4</code> targets
for common checks to ensure consistency and avoid duplication.</p>
<h2 id="migration-checklist"><a class="header" href="#migration-checklist">Migration Checklist</a></h2>
<p>When migrating, follow these steps:</p>
<ol>
<li><strong>Check for existing <code>//gnulib/m4</code> targets</strong> - Before writing checks, look for reusable targets
in <code>//gnulib/m4/</code> that provide the same functionality</li>
<li>Identify all M4 macro calls in <code>configure.ac</code></li>
<li>Map each macro to its Bazel equivalent (see function docstrings)</li>
<li>Convert argument syntax (brackets → quotes, lists → multiple calls)</li>
<li>Extract define names from action blocks</li>
<li>Convert include directives to <code>code</code> or <code>headers</code> parameters</li>
<li>Handle language selection (<code>AC_LANG_PUSH/POP</code> → <code>language</code> parameter)</li>
<li>Identify dependencies and add <code>requires</code> parameters, or use <code>if_true</code>/<code>if_false</code> for conditional action blocks</li>
<li>Convert action blocks (<code>[action-if-found]</code>/<code>[action-if-not-found]</code>) to <code>if_true</code>/<code>if_false</code> parameters (see Pattern 11c)</li>
<li>Split multi-item macros into individual calls</li>
<li><strong>Handle platform-specific conditionals</strong> (<code>case "$host_os"</code> → <code>select()</code>)</li>
<li>Create <code>package_info</code> from <code>AC_INIT</code></li>
<li>Create <code>autoconf_hdr</code> from <code>AC_CONFIG_HEADERS</code></li>
<li>Wrap all checks in <code>autoconf()</code> rule with <code>checks</code> list</li>
<li><strong>Add <code>//gnulib/m4</code> targets to <code>deps</code></strong> - Use pre-built targets for common checks</li>
<li>Verify no duplicate checks between direct checks and dependencies</li>
<li>Preserve comments and structure where possible</li>
</ol>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<ul>
<li><strong>Forgetting to split lists</strong>: <code>AC_CHECK_HEADERS([a b c])</code> needs 3 separate calls</li>
<li><strong>Missing main() wrapper</strong>: Custom code in <code>AC_TRY_COMPILE</code> needs <code>int main(void) { ... }</code></li>
<li><strong>Wrong define names</strong>: Auto-generated names follow patterns (see each macro's docstring)</li>
<li><strong>Language context</strong>: Remember to propagate <code>language = "cpp"</code> from <code>AC_LANG_PUSH([C++])</code></li>
<li><strong>Dependencies</strong>: Check if includes in code correspond to previous header checks</li>
<li><strong>Conditional action blocks</strong>: Use <code>if_true</code>/<code>if_false</code> parameters instead of manually managing <code>requires</code> when you have <code>[action-if-found]</code>/<code>[action-if-not-found]</code> blocks - this is cleaner and shows intent more clearly (see Pattern 11c)</li>
<li><strong>String values</strong>: Use <code>'"string"'</code> for string literals in <code>AC_DEFINE</code> values</li>
<li><strong>Platform conditionals</strong>: <code>case "$host_os"</code> patterns require <code>select()</code> with platform constraints</li>
<li><strong>Duplicate checks</strong>: Don't add a check (e.g., <code>AC_CHECK_FUNC("lstat")</code>) if you already depend on a module that provides it (e.g., <code>//gnulib/m4/lstat</code>). This will cause a "duplicate check" error.</li>
<li><strong>Not using <code>//gnulib/m4</code> targets</strong>: Before writing manual checks for common functions, headers, or types, check if a <code>//gnulib/m4/&lt;name&gt;</code> target already exists. These targets provide tested, platform-aware implementations and should be preferred over manual checks. Add them to your <code>deps</code> list instead of duplicating the checks.</li>
</ul>
<h2 id="macro-reference"><a class="header" href="#macro-reference">Macro Reference</a></h2>
<p>For detailed information about each macro's parameters, default behavior, and examples,
see the <a href="./macros.html">macros documentation</a>. Each function includes:</p>
<ul>
<li>Original M4 example</li>
<li>Bazel usage example</li>
<li>Parameter descriptions</li>
<li>Default define name generation rules</li>
</ul>
<h2 id="cross-compilation-warning"><a class="header" href="#cross-compilation-warning">Cross-Compilation Warning</a></h2>
<p>Some of the macros in this module behave like their GNU Autoconf counterparts
and are <strong>not cross‑compile friendly</strong>. In particular, any macro that needs to
<em>run</em> a compiled test binary will not behave well when the Bazel execution
platform differs from the target platform.</p>
<p>Macros that <strong>run</strong> test programs (and therefore are not safe for
cross‑compilation) include:</p>
<ul>
<li><code>AC_CHECK_SIZEOF</code> / <code>ac_check_sizeof</code> (computes <code>sizeof(...)</code> by running code)</li>
<li><code>AC_CHECK_ALIGNOF</code> / <code>ac_check_alignof</code> (computes alignment by running code)</li>
<li><code>AC_COMPUTE_INT</code> / <code>ac_compute_int</code> (evaluates an expression by running code)</li>
<li><code>AC_C_BIGENDIAN</code> / <code>ac_c_bigendian</code> (detects endianness at runtime)</li>
<li><code>AC_PROG_CC_C_O</code> / <code>ac_prog_cc_c_o</code> (probes compiler behaviour)</li>
</ul>
<p>These are still useful when you build and test on the <strong>same</strong> architecture as
your deployment target (e.g. local development, non‑cross CI), but you should
avoid or gate them when doing true cross‑compilation.</p>
<p>For cross‑compile scenarios prefer <strong>compile‑only</strong> checks such as:</p>
<ul>
<li><code>AC_CHECK_HEADER</code>, <code>AC_CHECK_FUNC</code>, <code>AC_CHECK_LIB</code>, <code>AC_CHECK_TYPE</code>, <code>AC_CHECK_SYMBOL</code></li>
<li>the various compiler‑flag checks (<code>AC_CHECK_C_COMPILER_FLAG</code>,
<code>AC_CHECK_CXX_COMPILER_FLAG</code>)</li>
<li>unconditional defines via <code>AC_DEFINE</code></li>
</ul>
<p>You can also conditionally enable the runtime‑based macros using Bazel
<code>select()</code>s, platforms, or build flags so they only run where they are safe.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="gnulib.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="gnulib.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
