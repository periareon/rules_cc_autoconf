"""GNU Autoconf Test Runner

Runs traditional autoconf and compares output to golden files.
"""

import difflib
import os
import platform
import re
import shutil
import subprocess
import sys
import unittest
from pathlib import Path

from python.runfiles import Runfiles


class GnuAutoconfTest(unittest.TestCase):
    """Test case for GNU autoconf comparison."""

    @classmethod
    def setUpClass(cls):
        """Set up test class with parsed arguments."""

        # Get file paths from environment variables
        configure_ac_rloc = os.environ["TEST_SRC_CONFIGURE_AC"]
        golden_file_rloc = os.environ["TEST_SRC_GOLDEN_FILE"]

        r = Runfiles.Create()
        if not r:
            raise EnvironmentError("Failed to locate runfiles")

        # Use runfiles to locate files
        source_repo = None
        if platform.system() == "Windows":
            source_repo = "_main"
        configure_ac_path = r.Rlocation(configure_ac_rloc, source_repo)
        if not configure_ac_path:
            raise FileNotFoundError(f"Failed to locate runfile: {configure_ac_rloc}")
        golden_file_path = r.Rlocation(golden_file_rloc, source_repo)
        if not golden_file_path:
            raise FileNotFoundError(f"Failed to locate runfile: {golden_file_rloc}")

        template_path = None
        if "TEST_SRC_TEMPLATE_FILE" in os.environ:
            template_rloc = os.environ["TEST_SRC_TEMPLATE_FILE"]
            template_path_str = r.Rlocation(template_rloc, source_repo)
            if not template_path_str:
                raise FileNotFoundError(f"Failed to locate runfile: {template_rloc}")
            template_path = Path(template_path_str)

        # TODO: This should be provided by Bazel.
        autoconf = shutil.which("autoconf")
        if not autoconf:
            autoconf = shutil.which("autoconf.exe")
        if not autoconf:
            raise EnvironmentError("autoconf is not installed or not in PATH")

        cls.configure_ac_path = Path(configure_ac_path)
        cls.golden_file_path = Path(golden_file_path)
        cls.template_path = template_path
        cls.autoconf = Path(autoconf)

    def setUp(self) -> None:
        outputs_dir = Path(os.environ["TEST_UNDECLARED_OUTPUTS_DIR"])
        self.work_dir = outputs_dir / self._testMethodName

        if not self.work_dir.exists():
            self.work_dir.mkdir(exist_ok=True, parents=True)

        # Copy configure.ac
        shutil.copy2(
            self.configure_ac_path, self.work_dir / self.configure_ac_path.name
        )
        if self.template_path:
            dest = self.work_dir / self.template_path.name
            shutil.copy2(self.template_path, dest)

        return super().setUp()

    def _run_autoconf(self) -> Path:
        """Run autoconf to generate configure script."""
        result = subprocess.run(
            [self.autoconf],
            cwd=self.work_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            check=False,
            text=True,
            encoding="utf-8",
        )

        print(result.stdout, file=sys.stderr)
        log_file = self.work_dir / "autoconf.log"
        log_file.write_text(result.stdout, encoding="utf-8")
        self.assertEqual(result.returncode, 0)

        # Check that configure was created
        configure_path = self.work_dir / "configure"
        self.assertTrue(configure_path.exists(), "configure script was not generated")

        # Make configure executable
        configure_path.chmod(0o755)

        return configure_path

    def _run_configure(self, configure: Path) -> Path:
        """Run the configure script generated by autoconf."""
        log_file = self.work_dir / "configure.log"
        result = subprocess.run(
            [str(configure)],
            cwd=self.work_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            check=False,
            text=True,
            encoding="utf-8",
        )

        print(result.stdout, file=sys.stderr)
        log_file = self.work_dir / "configure.log"
        log_file.write_text(result.stdout, encoding="utf-8")
        self.assertEqual(result.returncode, 0)

        # Check that config.h was created
        config_h = self.work_dir / "config.h"
        self.assertTrue(config_h.exists(), "config.h was not generated")

        return config_h

    def _normalize_config(self, content: str) -> str:
        """Normalize config.h content for comparison."""
        normalized = content

        # Remove all generation comment lines - they differ between tools
        # GNU Autoconf generates two lines:
        #   /* config.h.  Generated from config.h.in by configure.  */
        #   /* config.h.in.  Generated from configure.ac by autoheader.  */
        # rules_cc_autoconf with template generates one line:
        #   /* config.h.in.  Generated from configure.ac by autoheader.  */

        # Remove "/* config.h.  Generated..." comments
        gnu_generated_pattern = re.compile(
            r"/\*\s*config\.h\.\s+Generated[^\*]*\*/\s*\n?"
        )
        normalized = gnu_generated_pattern.sub("", normalized)

        # Remove "/* config.h.in.  Generated..." comments
        config_in_pattern = re.compile(
            r"/\*\s*config\.h\.in\.\s+Generated[^\*]*\*/\s*\n?"
        )
        normalized = config_in_pattern.sub("", normalized)

        # Normalize multiple consecutive blank lines to single blank line
        multiple_blanks = re.compile(r"\n\n\n+")
        normalized = multiple_blanks.sub("\n\n", normalized)

        # Trim trailing whitespace from each line
        lines = normalized.split("\n")
        normalized_lines = [line.rstrip() for line in lines]
        normalized = "\n".join(normalized_lines)

        return normalized

    def _compare_with_golden(self, config: Path) -> bool:
        """Compare generated config.h with golden file."""

        golden_content = Path(self.golden_file_path).read_text(encoding="utf-8")
        generated_content = config.read_text(encoding="utf-8")

        # Normalize both contents
        normalized_golden = self._normalize_config(golden_content)
        normalized_generated = self._normalize_config(generated_content)

        # Compare normalized contents
        if normalized_golden == normalized_generated:
            return

        # Show unified diff of normalized contents
        golden_lines = normalized_golden.splitlines()
        generated_lines = normalized_generated.splitlines()

        diff = difflib.unified_diff(
            golden_lines,
            generated_lines,
            fromfile=f"a/{self.golden_file_path.name}",
            tofile=f"b/{config.name}",
            lineterm="",
        )

        diff_output = "\n".join(diff)
        divider = "=" * 70

        self.fail(
            f"Generated config.h differs from golden file\n{divider}\n```diff\n{diff_output}\n```"
        )

    def test_autoconf_output_matches_golden(self):
        """Test that autoconf-generated config.h matches the golden file."""

        configure = self._run_autoconf()

        config_h = self._run_configure(configure)

        self._compare_with_golden(config_h)


if __name__ == "__main__":
    unittest.main()
